---
title: "Vector Fields in Augmented Reality"
description: "Visualizing vector fields on Snap Spectacles as arrows, particles, and trails using procedural tube meshes and real-time field integration."
pubDatetime: 2026-01-07T16:00:00Z
tags:
  [
    "augmented reality",
    "spectacles",
    "lens studio",
    "snap ar",
    "manim",
    "vector fields",
    "procedural geometry",
  ]
ogImage: /assets/vector-fields-og.gif
icon: /assets/visualizing-vector-fields-on-ar-glasses/icons/ghost-vector-fields.png
draft: false
---
import WorkflowDiagramSimple from "@components/WorkflowDiagramSimple";
import Chapter from "@components/Chapter";
import ArticleTimeline from "@components/ArticleTimeline";
import VideoPlayer from "@components/VideoPlayer";
import ManimVideo from "@components/ManimVideo";
import Note from "@components/Note";
import VectorFieldViz from "@components/VectorFieldViz";
import ExpandableImage from "@components/ExpandableImage";
import CodeSource from "@components/CodeSource";

{/* Hidden image for social media scrapers - must be first img tag */}
<img
	src="/assets/vector-fields-og.gif"
	alt="Vector Fields in Augmented Reality"
	style={{ position: "absolute", width: "1px", height: "1px", opacity: 0, pointerEvents: "none" }}
/>

<div
	style={{
		display: "flex",
		justifyContent: "center",
		alignItems: "center",
		gap: "24px",
		flexWrap: "wrap",
		fontFamily: '"Roboto Mono", monospace',
		fontSize: "13px",
		marginBottom: "8px",
	}}
>
	<a
		href="https://github.com/a-sumo/specs-samples/"
		style={{ display: "inline-flex", alignItems: "center", gap: "8px" }}
	>
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="24"
			height="24"
			viewBox="0 0 24 24"
			fill="currentColor"
		>
			<path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z" />
		</svg>
		a-sumo/specs-samples
	</a>
	<a
		href="https://www.spectacles.com/lens/588755bd7dd34c90a42f807104ef0bdf?type=SNAPCODE&metadata=01"
		style={{ display: "inline-flex", alignItems: "center", gap: "8px" }}
	>
		<img
			src="/assets/icons/snapcode-vector-fields.png"
			width="96"
			height="96"
			alt="Snapcode"
		/>
		Try on Spectacles
	</a>
</div>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/VectorFieldPreview.mp4"
	autoPlay={true}
	loop={true}
	muted={true}
	preload="auto"
	maxWidth="50%"
/>

To model wind around an aircraft wing, gravitational pull on satellites, or magnetic forces between poles, we use vector fields.

In essence, a vector field is a direction and magnitude assigned to every point in space.

More practically though, vector fields represent either *motion* itself, or what drives it such as a *force*.

There are three main approaches to visualize motion: 
1. We can divide space with sample points and show where each point is being pulled and how strongly. This is done with *arrows*. 
2. We can also show how an element with a mass moves when carried by the flow, which is done via *particles*. 
3. Or we can trace the paths a massless particle would follow through the field, with *flow lines*.

<div id="vector-field-viz">
<VectorFieldViz client:load fieldType="dipole" />
</div>

<ArticleTimeline
	client:load
	sections={[
		{ id: "chapter-1", label: "Rendering 3D Lines", type: "chapter" },
		{ id: "proc-gen-code", label: "Procedural Code", type: "sidequest", parent: "chapter-1" },
		{ id: "chapter-2", label: "GPU Deformation", type: "chapter" },
		{ id: "chapter-3", label: "Field Integration", type: "chapter" },
		{ id: "contraction", label: "Contraction", type: "sidequest", parent: "chapter-3" },
		{ id: "expansion", label: "Expansion", type: "sidequest", parent: "chapter-3" },
		{ id: "circulation", label: "Circulation", type: "sidequest", parent: "chapter-3" },
		{ id: "vortex", label: "Vortex", type: "sidequest", parent: "chapter-3" },
		{ id: "waves", label: "Waves", type: "sidequest", parent: "chapter-3" },
		{ id: "chapter-4", label: "Magnetic Field", type: "chapter" },
		{ id: "math-derivation", label: "Math Derivation", type: "sidequest", parent: "chapter-4" },
		{ id: "gpu-implementation", label: "GPU Implementation", type: "sidequest", parent: "chapter-4" },
		{ id: "magnet-physics", label: "Magnet Physics", type: "sidequest", parent: "chapter-4" },
		{ id: "chapter-5", label: "Performance", type: "chapter" },
		{ id: "chapter-6", label: "UX", type: "chapter" },
		{ id: "final-words", label: "Final Words", type: "chapter" },
	]}
/>

<Chapter client:load id="chapter-1" number={1} title="Rendering 3D Lines" />

Rendering vector fields in 2D is fairly straightforward.

In 3D on AR glasses, however, we need to satisfy a few constraints:

1. The geometry must look consistent from all viewing angles. A volumetric line shouldn't look flat from certain directions.

2. The geometry must adapt to its spatial context, which in this case is the direction and magnitude sampled at a spatial location. Importing static or pre-animated 3D objects wouldn't allow this kind of adaptivity, which means we must generate the geometry procedurally.  

3. It must run smoothly in real time, while looking believable, so we need a minimal rendering procedure.

The most straightforward approach to render 3D lines is to generate tubes with capped ends. In Lens Studio, we can do this via the MeshBuilder API, which we first explored in our [article on color spaces](/posts/visualizing-color-spaces-in-ar-glasses). 

If the normals are encoded correctly (which requires having proper vertex ordering), GPU interpolation provides smooth color transitions across the tube surface and endcaps, which yields a believable look with minimal geometry.

The animation below illustrates the construction process:

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeConstruction.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/tube_construction.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
/>

<span id="proc-gen-code"></span>
<Note client:load type="note" title="Procedural Generation Code" collapsible={true} id="proc-gen-code">

The tube body is generated by creating rings of vertices along the length, then connecting them with triangles:

```typescript
private generateSingleTube(gridX: number, gridY: number, pathLength: number, circleSegments: number): void {
    const startVertexIndex = this.meshBuilder.getVerticesCount();

    // Generate tube body vertices
    for (let i = 0; i < pathLength; i++) {
        const t = i / (pathLength - 1);

        for (let j = 0; j < circleSegments; j++) {
            const theta = (j / circleSegments) * Math.PI * 2;
            const localX = Math.cos(theta);
            const localY = Math.sin(theta);

            this.meshBuilder.appendVerticesInterleaved([
                0.0, 0.0, t,           // position: unused, unused, t
                0.0, 0.0, 1.0,         // normal: unused, unused, isTube=1
                localX, localY,        // texture0: unit circle coords
                gridX, gridY           // texture1: grid indices
            ]);
        }
    }

    // Generate indices for tube body
    for (let segment = 0; segment < pathLength - 1; segment++) {
        for (let i = 0; i < circleSegments; i++) {
            const current = startVertexIndex + segment * circleSegments + i;
            const next = startVertexIndex + segment * circleSegments + ((i + 1) % circleSegments);
            const currentNext = startVertexIndex + (segment + 1) * circleSegments + i;
            const nextNext = startVertexIndex + (segment + 1) * circleSegments + ((i + 1) % circleSegments);

            this.meshBuilder.appendIndices([
                current, next, currentNext,
                next, nextNext, currentNext
            ]);
        }
    }

    // Generate end caps for this tube
    this.generateSingleTubeCaps(gridX, gridY, startVertexIndex, pathLength, circleSegments);
}
```

The end caps are created by adding a center vertex and connecting it to the ring vertices in a fan pattern:

```typescript
private generateSingleTubeCaps(gridX: number, gridY: number, startVertexIndex: number, pathLength: number, circleSegments: number): void {
    const tubeVertexCount = pathLength * circleSegments;

    // START CAP (at t = 0)
    const startCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 0.0,         // position: unused, unused, t=0
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    for (let i = 0; i < circleSegments; i++) {
        const current = startVertexIndex + i;
        const next = startVertexIndex + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([startCapIndex, next, current]);
    }

    // END CAP (at t = 1)
    const endCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 1.0,         // position: unused, unused, t=1
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    const lastRingStart = startVertexIndex + (pathLength - 1) * circleSegments;
    for (let i = 0; i < circleSegments; i++) {
        const current = lastRingStart + i;
        const next = lastRingStart + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([endCapIndex, current, next]);
    }
}
```

</Note>

<Chapter client:load id="chapter-2" number={2} title="Deforming the 3D Lines on the GPU" />

Deforming 3D lines has an added difficulty of preserving the volume of the tube.
If we just offset point positions by the same vector, we end up with wrong endcaps.

<div style={{ display: "flex", gap: "24px", justifyContent: "center", flexWrap: "wrap" }}>
	<figure style={{ margin: 0, textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/videos/NaiveOffset.gif" alt="Naive offset - rings stay horizontal" loading="lazy" decoding="async" style={{ maxWidth: "280px", borderRadius: "8px" }} />
		<figcaption style={{ color: "#E63946", fontSize: "14px", marginTop: "8px" }}>Naive offset ✗</figcaption>
	</figure>
	<figure style={{ margin: 0, textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TNBFrame.gif" alt="TNB frame - rings perpendicular to tangent" loading="lazy" decoding="async" style={{ maxWidth: "280px", borderRadius: "8px" }} />
		<figcaption style={{ color: "#2A9D8F", fontSize: "14px", marginTop: "8px" }}>TNB frame ✓</figcaption>
	</figure>
</div>

The solution is to compute a moving coordinate frame along the path. At each point, we calculate:
- a **Tangent (T)** vector: The direction the tube is heading (derivative of the path)
- a **Normal (N)** vector: Perpendicular to the tangent
- a **Binormal (B)** vector: Cross product of tangent and normal

Each vertex is then positioned using: `p = center + (cos θ · N + sin θ · B) · radius`

<Note client:load type="important" title="Object to World Transform">
A key node from the material editor to make everything work is the **Object to World** converter. This transforms our computed vertex positions from object space into world space, ensuring the deformed tubes render correctly regardless of the object's transform.
Since you're here, I might as well recommend you another node: Hue/Saturation. 
Lens Studio renders low value colors as transparent, so by using this node you can adjust the value color channel independently. 
It's also useful for making colors pop by raising saturation.

<img src="/assets/visualizing-vector-fields-on-ar-glasses/captures/transform-vector-hue-saturation.png" alt="Material editor showing Transform Vector Object to World node" loading="lazy" decoding="async" style={{ width: "60%", borderRadius: "8px", marginTop: "12px" }} />
</Note>

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeDeformation.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/tube_deformation.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
/>

I implemented a test example in Lens Studio and deployed it on Spectacles. Performance was satisfactory, so I continued with this approach.
<div style={{ display: "flex", gap: "16px", justifyContent: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/test-tube-recording.mp4"
		preload="metadata"
		maxWidth="100%"
		autoPlay={true}
		loop={true}
		muted={true}
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeTestDemo.mp4"
		preload="metadata"
		maxWidth="100%"
		autoPlay={true}
		loop={true}
		muted={true}
	/>
</div>

Here's the workflow for this test example in Lens Studio:

<WorkflowDiagramSimple
	client:load
	scriptLabel="TubeTest.ts"
	materialLabel="TestTubeShader.mat"
	materialCapture="tube-deformation-material.png"
	scriptCodeFile="TubeTest.ts"
	materialCodeFile="TubeTestShader.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/TestTubeDeformation.lspkg"
/>

<Chapter client:load id="chapter-3" number={3} title="Creating and Integrating a Vector Field" />

With tube generation and deformation working, we can now trace paths through a vector field.

Starting from sample points, we integrate by repeatedly querying the field at the current position and stepping in that direction. 

Each step updates the tube's frame, bending it along the flow. 

Different field patterns produce vastly different flow lines.

<span id="contraction"></span>
#### 3.1 Contraction
Vectors spiral inward toward a target point, creating sink-like behavior.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldContraction.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
	caption="Field visualization showing contraction flow pattern"
	figureId="Fig 3.1a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/contraction-demo.mp4"
	preload="metadata"
	maxWidth="100%"
	autoPlay={true}
	loop={true}
	muted={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.1b: Demo on Spectacles</p>

<span id="expansion"></span>
#### 3.2 Expansion
Radial waves emanate outward from the target with 3D oscillation perpendicular to the flow.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldExpansion.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
	caption="Field visualization showing expansion flow pattern"
	figureId="Fig 3.2a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/expansion-demo.mp4"
	preload="metadata"
	maxWidth="100%"
	autoPlay={true}
	loop={true}
	muted={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.2b: Demo on Spectacles</p>

<span id="circulation"></span>
#### 3.3 Circulation
A 3D swirling vortex that mixes rotation in multiple planes around the target.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldCirculation.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
	caption="Field visualization showing circulation flow pattern"
	figureId="Fig 3.3a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/circulation-demo.mp4"
	preload="metadata"
	maxWidth="100%"
	autoPlay={true}
	loop={true}
	muted={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.3b: Demo on Spectacles</p>

<span id="vortex"></span>
#### 3.4 Vortex
Rotating cellular patterns with an added spin component based on angular position.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldVortex.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
	caption="Field visualization showing vortex flow pattern"
	figureId="Fig 3.4a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/vortex-demo.mp4"
	preload="metadata"
	maxWidth="100%"
	autoPlay={true}
	loop={true}
	muted={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.4b: Demo on Spectacles</p>

<span id="waves"></span>
#### 3.5 Waves
Sinusoidal interference patterns where each axis oscillates based on the other two coordinates.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldWaves.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
	caption="Field visualization showing wave interference pattern"
	figureId="Fig 3.5a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/waves-demo.mp4"
	preload="metadata"
	maxWidth="100%"
	autoPlay={true}
	loop={true}
	muted={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.5b: Demo on Spectacles</p>

#### 3.6 Implementation Workflow

The complete workflow connects a TypeScript component that generates procedural tube geometry with a custom shader that integrates the vector field on the GPU:

<WorkflowDiagramSimple
	client:load
	scriptLabel="VectorField.ts"
	materialLabel="VectorField.mat"
	materialCapture="vector-field-material.png"
	scriptCodeFile="VectorField.ts"
	materialCodeFile="VectorField.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/VectorField.lspkg"
/>

<Chapter client:load id="chapter-4" number={4} title="Magnetic Field Visualization" />
 
The field patterns above are mathematical abstractions. For something more concrete, we can model a magnetic dipole field, the kind you've probably seen with iron filings around bar magnets.

<div style={{ display: "flex", justifyContent: "center", margin: "24px 0" }}>
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/j8XNHlV6Qxg"
    title="Iron filings around bar magnets"
    frameBorder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
    style={{ borderRadius: "8px", maxWidth: "100%" }}
  />
</div>

<span id="math-derivation"></span>
<Note client:load type="note" title="Math: Dipole Field & Integration" collapsible={true} defaultOpen={true} id="math-derivation">

Each dipole creates a vector field based on its magnetic moment $\mathbf{m}$ and the displacement $\mathbf{r}$ from the dipole:

$$\mathbf{B}(\mathbf{r}) = \frac{3(\mathbf{m} \cdot \hat{\mathbf{r}})\hat{\mathbf{r}} - \mathbf{m}}{r^3}$$

The field magnitude falls off as the inverse cube of distance: $|\mathbf{B}| \propto \frac{1}{r^3}$.

To trace flow lines through this field, we use Euler integration: starting from a sample point $\mathbf{p}_0$, we repeatedly query the field and step in its direction:

$$\mathbf{p}_{n+1} = \mathbf{p}_n + \hat{\mathbf{B}}(\mathbf{p}_n) \cdot \Delta s$$

where $\hat{\mathbf{B}}$ is the normalized field direction and $\Delta s$ is the step size. Combining two dipoles produces the characteristic looping field lines.

</Note>

<span id="gpu-implementation"></span>
<Note client:load type="note" title="GPU Implementation" collapsible={true} defaultOpen={true} id="gpu-implementation">

The dipole formula translates directly to GPU code:

```javascript
vec3 dipoleMagneticField(vec3 point, vec3 dipolePos, vec3 moment) {
    vec3 r = point - dipolePos;
    float dist = length(r);

    if (dist < 0.1) {
        return moment * FieldStrength * 2.0;  // Inside dipole
    } else {
        vec3 rHat = r / dist;                           // r̂ = r/|r|
        float dist3 = dist * dist * dist;               // r³
        float mDotR = dot(moment, rHat);                // m · r̂
        vec3 B = (3.0 * mDotR * rHat - moment) / dist3; // B = (3(m·r̂)r̂ - m) / r³
        return B * FieldStrength;
    }
}
```

Euler integration runs in the vertex shader, stepping each vertex along the field:

```javascript
for (int i = 0; i < 64; i++) {
    if (i >= clampedStepIndex) break;
    prevPos = pos;
    pos += getMagneticField(pos) * StepSize;  // p_{n+1} = p_n + B(p_n) · Δs
}
```

</Note>

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/MagneticField.gif"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/magnetic_field.py"
	maxWidth="100%"
	noBorder={true}
	gif={true}
	caption="Magnetic field visualization showing dipole field computation and integration"
	figureId="Fig 4.1"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/magnetic-field-demo.mp4"
	preload="metadata"
	maxWidth="100%"
	autoPlay={true}
	loop={true}
	muted={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 4.2: Demo on Spectacles with interactive magnet positioning</p>

<span id="magnet-physics"></span>
<Note client:load type="tip" title="Magnet Physics Script" collapsible={true} id="magnet-physics">

A separate script applies physical interactions between the two magnet scene objects.

Here are some of its key sections:

**Pole alignment** that determines whether magnets attract or repel:

```typescript
// Returns alignment: negative = attracting, positive = repelling
private computeAlignment(): number {
    const direction = delta.normalize();
    const m1 = this.getForwardVector(this.magnet1);  // +X points from S to N pole
    const m2 = this.getForwardVector(this.magnet2);

    const m1FacingM2 = m1.dot(direction);            // Is magnet1's north pointing toward magnet2?
    const m2FacingM1 = m2.dot(direction.uniformScale(-1)); // Is magnet2's north pointing toward magnet1?
    return m1FacingM2 * m2FacingM1;                  // Negative when opposite poles face each other
}
```

**Force computation** with inverse cube falloff (matching the dipole field formula) and reference distance normalization for intuitive parameter tuning:

```typescript
const effectiveDistance = Math.max(distance, this.minDistance);
// Normalize by reference distance (≈ magnet diameter) so force = 1 at that distance
const normalizedDist = effectiveDistance / this.referenceDistance;
const distanceFactor = normalizedDist * normalizedDist * normalizedDist; // r³ falloff

// Boost attraction at close range for satisfying "snap" behavior
const isAttracting = alignment < 0;
const proximityFactor = Math.max(0, 1.0 - effectiveDistance / 2.0);
const closeRangeBoost = isAttracting ? (1.0 + 8.0 * proximityFactor * proximityFactor) : 1.0;

const forceMagnitude = this.forceStrength * alignmentFactor * closeRangeBoost / distanceFactor;
return direction.uniformScale(forceMagnitude * alignment);
```

**Sticking behavior** where attracting magnets stick together and move as one until shaken apart:

```typescript
if (attracting && distance < contactDist) {
    if (!this.isStuck) {
        this.stickOffset = pos2.sub(pos1);  // Record relative position
    }
    this.isStuck = true;

    // When stuck, moving one magnet moves both
    if (manipulating1 && !manipulating2) {
        this.setPosition(this.magnet2, pos1.add(this.stickOffset));
    } else if (manipulating2 && !manipulating1) {
        this.setPosition(this.magnet1, pos2.sub(this.stickOffset));
    }
}
```

**Shake to separate** that detects rapid hand acceleration to break stuck magnets apart:

```typescript
private checkShakeSeparation(currentVel: vec3, lastVel: vec3, isManipulating: boolean): boolean {
    if (!isManipulating) return false;

    const acceleration = currentVel.sub(lastVel).length / dt;
    if (acceleration > this.shakeThreshold) {
        this.isStuck = false;
        // Apply impulse in opposite directions
        this.velocity1 = direction.uniformScale(-this.separationImpulse);
        this.velocity2 = direction.uniformScale(this.separationImpulse);
        return true;
    }
    return false;
}
```

</Note>

#### 4.1 Implementation Workflow

The magnetic field implementation uses the same tube mesh generation approach but with a physically-based dipole field formula in the shader:

<WorkflowDiagramSimple
	client:load
	scriptLabel="MagneticField.ts"
	materialLabel="MagneticField.mat"
	materialCapture="magnetic-field-material.png"
	scriptCodeFile="MagneticField.ts"
	materialCodeFile="MagneticField.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/MagneticField.lspkg"
/>


#### 4.2 Visualization Modes

This implementation supports three visualization modes that can be toggled at runtime:

- **Arrows**: Static vectors showing direction and magnitude at discrete sample points. Best for understanding local field behavior.
- **Trails**: Tubes that follow field lines by integrating through the field. Shows how the field flows through space.
- **Particles**: Animated points that advect along the field, revealing the dynamic nature of the flow.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/vector-field2-tube-mode-demo.mp4"
	preload="metadata"
	maxWidth="50%"
	autoPlay={true}
	loop={true}
	muted={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Demo showing the three visualization modes: arrows, flow lines, and particles</p>

<Chapter client:load id="chapter-5" number={5} title="Performance Considerations" />

To ensure smooth performance on Spectacles and avoid freezes from unintentionally high geometry counts, I've defined a vertex budget (32K vertices per mesh). All procedural geometry settings automatically adapt to fit within this budget.

I've also defined Level of Detail (LOD) presets accessible via the settings panel, controlling:
- **Radial segments**: Cross-section smoothness (4 = square-ish, 8 = round)
- **Length segments**: Curve fidelity and field integration steps
- **Grid size**: Spatial density of field samples (e.g., 6³ = 216 tubes, 8³ = 512 tubes)

Among the three visualization modes, **Trails** is the most expensive due to many length segments per tube, while **Particles** uses minimal geometry (just 2 rings + caps per tube). **Arrows** mode has no flow animation overhead since it's static.

<Chapter client:load id="chapter-6" number={6} title="UX" />

To give users a visual hint of the active preset, I rendered a 2D version of each vector field with color-mapped direction and magnitude: hue encodes angle, saturation/brightness encodes strength.

<div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", maxWidth: "500px", margin: "16px auto" }}>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/field_source.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Source</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/field_saddle.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Saddle</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/field_double_vortex.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Double Vortex</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Examples of fields with color discontinuities at singular points</p>

Getting smooth gradients required careful attention to continuity in the field functions, both spatially (no jumps in color) and temporally (smooth animation).

<div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", maxWidth: "600px", margin: "0 auto" }}>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/contraction.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Contraction</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/expansion.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Expansion</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/circulation.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Circulation</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/vortex.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Vortex</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/waves.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Waves</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/magnetic.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Magnetic</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "8px" }}>2D color-mapped visualizations of each vector field preset</p>

Adding an alpha falloff:

<div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", maxWidth: "600px", margin: "16px auto" }}>
	<div style={{ textAlign: "center" }}>
		<video src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/contraction_animated.webm" poster="/assets/visualizing-vector-fields-on-ar-glasses/sprites/contraction_preview.png" autoPlay loop muted playsInline style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Contraction</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<video src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/expansion_animated.webm" poster="/assets/visualizing-vector-fields-on-ar-glasses/sprites/expansion_preview.png" autoPlay loop muted playsInline style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Expansion</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<video src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/circulation_animated.webm" poster="/assets/visualizing-vector-fields-on-ar-glasses/sprites/circulation_preview.png" autoPlay loop muted playsInline style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Circulation</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<video src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/vortex_animated.webm" poster="/assets/visualizing-vector-fields-on-ar-glasses/sprites/vortex_preview.png" autoPlay loop muted playsInline style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Vortex</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<video src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/waves_animated.webm" poster="/assets/visualizing-vector-fields-on-ar-glasses/sprites/waves_preview.png" autoPlay loop muted playsInline style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Waves</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<video src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/magnetic_animated.webm" poster="/assets/visualizing-vector-fields-on-ar-glasses/sprites/magnetic_preview.png" autoPlay loop muted playsInline style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Magnetic</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Animated previews with radial alpha falloff</p>

Finally, I packed all frames into a sprite sheet:

<div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "12px", maxWidth: "900px", margin: "16px auto" }}>
	<div style={{ textAlign: "center" }}>
		<ExpandableImage
			client:load
			src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/contraction_sprite.png"
			alt="Contraction sprite sheet"
			caption="Contraction sprite sheet"
		/>
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Contraction</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<ExpandableImage
			client:load
			src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/expansion_sprite.png"
			alt="Expansion sprite sheet"
			caption="Expansion sprite sheet"
		/>
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Expansion</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<ExpandableImage
			client:load
			src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/circulation_sprite.png"
			alt="Circulation sprite sheet"
			caption="Circulation sprite sheet"
		/>
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Circulation</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<ExpandableImage
			client:load
			src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/vortex_sprite.png"
			alt="Vortex sprite sheet"
			caption="Vortex sprite sheet"
		/>
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Vortex</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<ExpandableImage
			client:load
			src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/waves_sprite.png"
			alt="Waves sprite sheet"
			caption="Waves sprite sheet"
		/>
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Waves</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<ExpandableImage
			client:load
			src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/magnetic_sprite.png"
			alt="Magnetic sprite sheet"
			caption="Magnetic sprite sheet"
		/>
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Magnetic</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Click any sprite sheet to expand</p>

<CodeSource
	client:load
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/scripts/render_field_sprites.py"
	label="Sprite Rendering Script"
	language="python"
	maxWidth="600px"
/>

The final shader samples the correct frame based on elapsed time, computing UV coordinates into the grid. It also supports smooth blending between presets.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/settings-bg-demo-bg.mp4"
	preload="metadata"
	maxWidth="70%"
/>

<CodeSource
	client:load
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/scripts/AnimatedSpriteSheet.js"
	label="Animated Sprite Sheet Shader"
	language="glsl"
	maxWidth="800px"
/>

<div style={{ display: "flex", justifyContent: "center", margin: "16px 0" }}>
	<img src="/assets/visualizing-vector-fields-on-ar-glasses/captures/animated-sprite-sheet.png" alt="Animated sprite sheet material graph" loading="lazy" decoding="async" style={{ maxWidth: "600px", borderRadius: "8px" }} />
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic" }}>Material graph for the animated sprite sheet shader</p>

---

<span id="final-words"></span>
## Final Words

I hope this exploration of vector fields in AR encourages you to leverage them in your projects, or just make something fun with procedural geometry.

Motion is something I'm very passionate about. Having a framework to visualize it in real-time on AR glasses opens up possibilities I hadn't considered before.

What I'm most excited about is using vector fields to manipulate data. Thanks to hand and body tracking input, I have a feeling that vector fields could become a full-fledged UI element category for XR applications.

Before getting into these considerations though, I'll need to conclude my series on AR painting assistants, where I'll use what I've learned from this project to push my experimentation with more fluid and cohesive UI elements.

If you want to try the project yourself, grab the [source code](https://github.com/a-sumo/specs-samples/) or scan the Snapcode at the top to experience it on Spectacles.