---
title: "Vector Fields in Augmented Reality"
description: ""
pubDatetime: 2026-01-05T21:00:00Z
tags:
  [
    "augmented reality",
    "spectacles",
    "lens studio",
    "snap ar",
    "manim",
    "vector fields",

    "procedural geometry",
  ]
ogImage: /assets/MagneticFieldDemo.gif
draft: true
---
import WorkflowDiagram from "@components/WorkflowDiagram";
import WorkflowDiagramSimple from "@components/WorkflowDiagramSimple";
import ColorMixingChallenge from "@components/ColorMixingChallenge";
import CollapsibleVideo from "@components/CollapsibleVideo";
import HoverReveal from "@components/HoverReveal";
import CollapsibleCode from "@components/CollapsibleCode";
import ReferencePreview from "@components/ReferencePreview";
import Chapter from "@components/Chapter";
import ArticleTimeline from "@components/ArticleTimeline";
import VideoPlayer from "@components/VideoPlayer";
import ManimVideo from "@components/ManimVideo";
import SeriesNav from "@components/SeriesNav";
import VectorFieldViz from "@components/VectorFieldViz";

<div style={{ display: "flex", gap: "8px", justifyContent: "center", alignItems: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/Vector-Field-demo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/MagneticFieldDemo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
</div>

If you try to model the speed and direction of the wind that hits a plane, or the strengh and direction of the gravitational force that 
keeps satellites orbiting around the Earth, you will necessarily cross paths with Vector fields. 
If you want I'd recommend Bartosz Ciechanowsky Airfoil for a primer on the contexts where vector fields might be useful. https://ciechanow.ski/airfoil/

At their core, these are a mathematical structure that assign a value, in our case a vector for each point in space. If this vector only has one coordinates,
we call it scalar field. If it has less than three coordinates, we call it a vector field, and from 4 and above we call them Tensor Fields.
Each vector encodes the direction and magnitude. 

They're used to drive smoke simulations, fluid, advect particles, or influence soft body movement.
Their visualization is generally done in one of either approaches: arrows, particles or trail lines.

<VectorFieldViz client:load fieldType="dipole" />

<ArticleTimeline
	client:load
	sections={[
		{ id: "chapter-1", label: "Rendering 3D Lines", type: "chapter" },
		{ id: "proc-gen-code", label: "Proc Gen Code", type: "subsection", parent: "chapter-1" },
		{ id: "chapter-2", label: "Deforming Lines on GPU", type: "chapter" },
		{ id: "chapter-3", label: "Vector Field Integration", type: "chapter" },
		{ id: "contraction", label: "Contraction", type: "subsection", parent: "chapter-3" },
		{ id: "expansion", label: "Expansion", type: "subsection", parent: "chapter-3" },
		{ id: "circulation", label: "Circulation", type: "subsection", parent: "chapter-3" },
		{ id: "vortex", label: "Vortex", type: "subsection", parent: "chapter-3" },
		{ id: "waves", label: "Waves", type: "subsection", parent: "chapter-3" },
		{ id: "chapter-4", label: "Magnetic Field", type: "chapter" },
	]}
/>

<Chapter client:load id="chapter-1" number={1} title="Rendering 3D Lines" />

The approach to rendering 3D lines consists in generating tubes with capped ends. Lens Studio offers a MeshBuilder API, which we first explored in our [article on color spaces](/posts/visualizing-color-spaces-in-ar-glasses). If the normals are encoded correctly, which is contingent on having a correct vertex order, the GPU vertex interpolation will provide smooth color transitions across the base of the tube and across endcaps.
Here's the geometry construction process.
<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeConstruction.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/tube_construction.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>

<span id="proc-gen-code"></span>
<details>
<summary style={{ cursor: "pointer", color: "#888", fontStyle: "italic" }}>Procedural Generation Code</summary>

The tube body is generated by creating rings of vertices along the length, then connecting them with triangles:

```typescript
private generateSingleTube(gridX: number, gridY: number, pathLength: number, circleSegments: number): void {
    const startVertexIndex = this.meshBuilder.getVerticesCount();

    // Generate tube body vertices
    for (let i = 0; i < pathLength; i++) {
        const t = i / (pathLength - 1);

        for (let j = 0; j < circleSegments; j++) {
            const theta = (j / circleSegments) * Math.PI * 2;
            const localX = Math.cos(theta);
            const localY = Math.sin(theta);

            this.meshBuilder.appendVerticesInterleaved([
                0.0, 0.0, t,           // position: unused, unused, t
                0.0, 0.0, 1.0,         // normal: unused, unused, isTube=1
                localX, localY,        // texture0: unit circle coords
                gridX, gridY           // texture1: grid indices
            ]);
        }
    }

    // Generate indices for tube body
    for (let segment = 0; segment < pathLength - 1; segment++) {
        for (let i = 0; i < circleSegments; i++) {
            const current = startVertexIndex + segment * circleSegments + i;
            const next = startVertexIndex + segment * circleSegments + ((i + 1) % circleSegments);
            const currentNext = startVertexIndex + (segment + 1) * circleSegments + i;
            const nextNext = startVertexIndex + (segment + 1) * circleSegments + ((i + 1) % circleSegments);

            this.meshBuilder.appendIndices([
                current, next, currentNext,
                next, nextNext, currentNext
            ]);
        }
    }

    // Generate end caps for this tube
    this.generateSingleTubeCaps(gridX, gridY, startVertexIndex, pathLength, circleSegments);
}
```

The end caps are created by adding a center vertex and connecting it to the ring vertices in a fan pattern:

```typescript
private generateSingleTubeCaps(gridX: number, gridY: number, startVertexIndex: number, pathLength: number, circleSegments: number): void {
    const tubeVertexCount = pathLength * circleSegments;

    // START CAP (at t = 0)
    const startCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 0.0,         // position: unused, unused, t=0
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    for (let i = 0; i < circleSegments; i++) {
        const current = startVertexIndex + i;
        const next = startVertexIndex + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([startCapIndex, next, current]);
    }

    // END CAP (at t = 1)
    const endCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 1.0,         // position: unused, unused, t=1
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    const lastRingStart = startVertexIndex + (pathLength - 1) * circleSegments;
    for (let i = 0; i < circleSegments; i++) {
        const current = lastRingStart + i;
        const next = lastRingStart + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([endCapIndex, current, next]);
    }
}
```

</details>

Here's the complete worflow:
<WorkflowDiagramSimple
	client:load
	scriptLabel="TubeTest.ts"
	materialLabel="TestTubeShader.mat"
	materialCapture="tube-deformation-material.png"
	scriptCodeFile="TubeTest.ts"
	materialCodeFile="TubeTestShader.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/TestTubeDeformation.lspkg"
/>

<Chapter client:load id="chapter-2" number={2} title="Deforming the 3D Lines on the GPU" />

Deforming 3D lines has an added difficulty of preserving the volume of the tube.
If we just offset point positions by the same vector, we end up with wrong endcaps.

<div style={{ display: "flex", gap: "24px", justifyContent: "center", flexWrap: "wrap" }}>
	<figure style={{ margin: 0, textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/videos/NaiveOffset.gif" alt="Naive offset - rings stay horizontal" style={{ maxWidth: "280px", borderRadius: "8px" }} />
		<figcaption style={{ color: "#E63946", fontSize: "14px", marginTop: "8px" }}>Naive offset ✗</figcaption>
	</figure>
	<figure style={{ margin: 0, textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TNBFrame.gif" alt="TNB frame - rings perpendicular to tangent" style={{ maxWidth: "280px", borderRadius: "8px" }} />
		<figcaption style={{ color: "#2A9D8F", fontSize: "14px", marginTop: "8px" }}>TNB frame ✓</figcaption>
	</figure>
</div>

The solution is to compute a moving coordinate frame along the path. At each point, we calculate:
- a **Tangent (T)** vector: The direction the tube is heading (derivative of the path)
- a **Normal (N)** vector: Perpendicular to the tangent
- a **Binormal (B)** vector: Cross product of tangent and normal

Each vertex is then positioned using: `p = center + (cos θ · N + sin θ · B) · radius`
A key node from the material editor to make everything work is the Object to World converter.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeDeformation.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/tube_deformation.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<div style={{ display: "flex", gap: "16px", justifyContent: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/test-tube-recording.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeTestDemo.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
</div>

<Chapter client:load id="chapter-3" number={3} title="Creating and Integrating a Vector Field" />
Now that we have a solid approach for procedural tube mesh deformation, we can deform the meshes along the vector field.
A vector field stores vector at each coordinate in space, so for each point of the tube's frame, we can sample that vector to infer the position change to apply.
If we keep the tubes' origin static, prevent their deformation along the frame but simply change their orientation, we get an actual arrow representation of the vector field.

To trace paths through the field, we integrate: starting from a sample point, we repeatedly query the field and step in that direction: `pos += field(pos) * stepSize`. At each step, we compute a local T/N/B (Tangent, Normal, Binormal) coordinate frame that follows the path curvature.

The shader supports several field presets, each with distinct flow characteristics:

<span id="contraction"></span>
#### 3.1 Contraction
Vectors spiral inward toward a target point, creating sink-like behavior.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldContraction.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
	caption="Field visualization showing contraction flow pattern"
	figureId="Fig 3.1a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/contraction-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.1b: Demo on Spectacles</p>

<span id="expansion"></span>
#### 3.2 Expansion
Radial waves emanate outward from the target with 3D oscillation perpendicular to the flow.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldExpansion.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
	caption="Field visualization showing expansion flow pattern"
	figureId="Fig 3.2a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/expansion-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.2b: Demo on Spectacles</p>

<span id="circulation"></span>
#### 3.3 Circulation
A 3D swirling vortex that mixes rotation in multiple planes around the target.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldCirculation.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
	caption="Field visualization showing circulation flow pattern"
	figureId="Fig 3.3a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/circulation-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.3b: Demo on Spectacles</p>

<span id="vortex"></span>
#### 3.4 Vortex
Rotating cellular patterns with an added spin component based on angular position.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldVortex.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
	caption="Field visualization showing vortex flow pattern"
	figureId="Fig 3.4a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/vortex-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.4b: Demo on Spectacles</p>

<span id="waves"></span>
#### 3.5 Waves
Sinusoidal interference patterns where each axis oscillates based on the other two coordinates.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldWaves.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/vector_field_presets.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
	caption="Field visualization showing wave interference pattern"
	figureId="Fig 3.5a"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/waves-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.5b: Demo on Spectacles</p>

#### 3.6 Implementation Workflow

The complete workflow connects a TypeScript component that generates procedural tube geometry with a custom shader that integrates the vector field on the GPU:

<WorkflowDiagramSimple
	client:load
	scriptLabel="VectorField.ts"
	materialLabel="VectorField.mat"
	materialCapture="vector-field-material.png"
	scriptCodeFile="VectorField.ts"
	materialCodeFile="VectorField.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/VectorField.lspkg"
/>

<Chapter client:load id="chapter-4" number={4} title="Magnetic Field Visualization" />

Magnetic fields from dipole magnets follow a specific physical formula. Each dipole creates a field that depends on the magnetic moment and distance: `B = (3(m·r̂)r̂ - m) / r³`. When combining two dipoles, the resulting field creates the characteristic field line patterns seen around bar magnets.

<ManimVideo
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/MagneticField.webm"
	codeSrc="/assets/visualizing-vector-fields-on-ar-glasses/manim/magnetic_field.py"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
	caption="Magnetic field visualization showing dipole field computation and integration"
	figureId="Fig 4.1"
/>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/magnetic-field-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 4.2: Demo on Spectacles with interactive magnet positioning</p>

#### 4.1 Implementation Workflow

The magnetic field implementation uses the same tube mesh generation approach but with a physically-based dipole field formula in the shader:

<WorkflowDiagramSimple
	client:load
	scriptLabel="MagneticField.ts"
	materialLabel="MagneticField.mat"
	materialCapture="magnetic-field-material.png"
	scriptCodeFile="MagneticField.ts"
	materialCodeFile="MagneticField.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/MagneticField.lspkg"
/>


### Visualization Modes

This implementation supports three visualization modes that can be toggled at runtime:

- **Arrows**: Static vectors showing direction and magnitude at discrete sample points. Best for understanding local field behavior.
- **Trails**: Tubes that follow field lines by integrating through the field. Shows how the field flows through space.
- **Particles**: Animated points that advect along the field, revealing the dynamic nature of the flow.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/vector-field2-tube-mode-demo.mp4"
	preload="metadata"
	maxWidth="50%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Demo showing the three visualization modes: arrows, flow lines, and particles</p>

## Performance Considerations

To ensure smooth performance on Spectacles and avoid freezes from unintentionally high geometry counts, I've defined a vertex budget (32K vertices per mesh). All procedural geometry settings automatically adapt to fit within this budget.

I've also defined Level of Detail (LOD) presets accessible via the settings panel, controlling:
- **Radial segments**: Cross-section smoothness (4 = square-ish, 8 = round)
- **Length segments**: Curve fidelity and field integration steps
- **Grid size**: Spatial density of field samples (e.g., 6³ = 216 tubes, 8³ = 512 tubes)

Among the three visualization modes, **Trails** is the most expensive due to many length segments per tube, while **Particles** uses minimal geometry (just 2 rings + caps per tube). **Arrows** mode has no flow animation overhead since it's static.

## UX

I've been exploring ways to make the UX more cohesive by binding data across various scene elements, making UI feel like part of a single multi-modular entity.

Next to the Lens title, I implemented a visual hint for the active vector field preset using a Python script that renders a 2D slice of each vector field. The direction and magnitude of each vector are mapped to color: hue encodes direction (angle), while saturation/brightness encode magnitude.
The tricky parts were getting the vector field formulas to produce smooth color gradients in time and space. In space this meant no discontinuities in the functions used to generate the 2d vector fields.

<div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", maxWidth: "500px", margin: "16px auto" }}>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/field_source.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Source</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/field_saddle.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Saddle</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/field_double_vortex.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Double Vortex</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Examples of fields with color discontinuities at singular points</p>

In time, it translated in a perfect looping animation, which was achieved by composing the vector field function with periodic functions, whose period(looping number) was known in advance.

<div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", maxWidth: "600px", margin: "0 auto" }}>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/contraction.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Contraction</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/expansion.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Expansion</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/circulation.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Circulation</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/vortex.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Vortex</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/waves.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Waves</p>
	</div>
	<div style={{ textAlign: "center", borderRadius: "8px", overflow: "hidden" }}>
		<VideoPlayer client:load src="/assets/visualizing-vector-fields-on-ar-glasses/videos/magnetic.mp4" autoPlay={true} loop={true} muted={true} preload="auto" maxWidth="100%" noBorder={true} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Magnetic</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "8px" }}>2D color-mapped visualizations of each vector field preset</p>

We can't bring these videos into the scene in their raw state. We first need to add some kind of alpha falloff near the borders, and because transparency in videos is poorly supported, this is not particular to Lens Studio actually, as I spent over 2 hours figuring out encoding and video editing software presets to produce Webms that include a transparency channel.
Now we could use GIFs too which do support transparency. But the most compact way of encoding such animations is sprite sheets: a Python script renders each frame with radial alpha falloff, then combines all frames into a single PNG that the shader samples based on time.

<div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", maxWidth: "600px", margin: "16px auto" }}>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/contraction_preview.png" alt="Contraction frames with alpha" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Contraction</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/expansion_preview.png" alt="Expansion frames with alpha" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Expansion</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/circulation_preview.png" alt="Circulation frames with alpha" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Circulation</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/vortex_preview.png" alt="Vortex frames with alpha" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Vortex</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/waves_preview.png" alt="Waves frames with alpha" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Waves</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/magnetic_preview.png" alt="Magnetic frames with alpha" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Magnetic</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Frame previews with radial alpha falloff applied</p>

The final sprite sheets pack all frames into a grid:

<div style={{ display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "12px", maxWidth: "800px", margin: "16px auto" }}>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/contraction_sprite.png" alt="Contraction sprite sheet" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Contraction</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/expansion_sprite.png" alt="Expansion sprite sheet" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Expansion</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/vortex_sprite.png" alt="Vortex sprite sheet" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Vortex</p>
	</div>
	<div style={{ textAlign: "center" }}>
		<img src="/assets/visualizing-vector-fields-on-ar-glasses/sprites/waves_sprite.png" alt="Waves sprite sheet" style={{ width: "100%", borderRadius: "8px" }} />
		<p style={{ fontSize: "0.75em", color: "#888", margin: "4px 0" }}>Waves</p>
	</div>
</div>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Sprite sheets - each contains all animation frames in a grid</p>
