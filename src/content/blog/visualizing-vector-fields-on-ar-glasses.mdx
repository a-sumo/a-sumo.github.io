---
title: "Vector Fields in Augmented Reality"
description: ""
pubDatetime: 2026-01-05T21:00:00Z
tags:
  [
    "augmented reality",
    "spectacles",
    "lens studio",
    "snap ar",
    "manim",
    "vector fields",

    "procedural geometry",
  ]
ogImage: /assets/MagneticFieldDemo.gif
draft: true
---
import WorkflowDiagram from "@components/WorkflowDiagram";
import WorkflowDiagramSimple from "@components/WorkflowDiagramSimple";
import ColorMixingChallenge from "@components/ColorMixingChallenge";
import CollapsibleVideo from "@components/CollapsibleVideo";
import HoverReveal from "@components/HoverReveal";
import CollapsibleCode from "@components/CollapsibleCode";
import ReferencePreview from "@components/ReferencePreview";
import Chapter from "@components/Chapter";
import ArticleTimeline from "@components/ArticleTimeline";
import VideoPlayer from "@components/VideoPlayer";
import SeriesNav from "@components/SeriesNav";
import VectorFieldViz from "@components/VectorFieldViz";

<div style={{ display: "flex", gap: "8px", justifyContent: "center", alignItems: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/Vector-Field-demo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/MagneticFieldDemo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
</div>

If you try to model the speed and direction of the wind that hits a plane, or the strengh and direction of the gravitational force that 
keeps satellites orbiting around the Earth, you will necessarily cross paths with Vector fields. 
If you want I'd recommend Bartosz Ciechanowsky Airfoil for a primer on the contexts where vector fields might be useful. https://ciechanow.ski/airfoil/

At their core, these are a mathematical structure that assign a value, in our case a vector for each point in space. If this vector only has one coordinates,
we call it scalar field. If it has less than three coordinates, we call it a vector field, and from 4 and above we call them Tensor Fields.
Each vector encodes the direction and magnitude. 

They're used to drive smoke simulations, fluid, advect particles, or influence soft body movement. 
Their visualization is generally done in one of either approaches: arrows, particles or trail lines. 

<VectorFieldViz client:load fieldType="dipole" />

<ArticleTimeline
	client:load
	sections={[
		{ id: "chapter-1", label: "Rendering 3D Lines", type: "chapter" },
		{ id: "chapter-2", label: "Deforming Lines on GPU", type: "chapter" },
		{ id: "chapter-3", label: "Vector Field Integration", type: "chapter" },
		{ id: "contraction", label: "Contraction", type: "subsection", parent: "chapter-3" },
		{ id: "expansion", label: "Expansion", type: "subsection", parent: "chapter-3" },
		{ id: "circulation", label: "Circulation", type: "subsection", parent: "chapter-3" },
		{ id: "vortex", label: "Vortex", type: "subsection", parent: "chapter-3" },
		{ id: "waves", label: "Waves", type: "subsection", parent: "chapter-3" },
		{ id: "chapter-4", label: "Magnetic Field", type: "chapter" },
	]}
/>

<Chapter client:load id="chapter-1" number={1} title="Rendering 3D Lines" />

The approach to rendering 3D lines consists in generating tubes with capped ends. Lens Studio offers a MeshBuilder API, which we first explored in our [article on color spaces](/posts/visualizing-color-spaces-in-ar-glasses). If the normals are encoded correctly, which is contingent on having a correct vertex order, the GPU vertex interpolation will provide smooth color transitions across the base of the tube and across endcaps.
I've made a Manim visualization that showcases the geometry construction process.
<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeConstruction.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>

<CollapsibleCode
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/scripts/VolumetricLine.ts"
	trigger="View VolumetricLine.ts"
	language="typescript"
/>

The tube body is generated by creating rings of vertices along the length, then connecting them with triangles:

```typescript
private generateSingleTube(gridX: number, gridY: number, pathLength: number, circleSegments: number): void {
    const startVertexIndex = this.meshBuilder.getVerticesCount();

    // Generate tube body vertices
    for (let i = 0; i < pathLength; i++) {
        const t = i / (pathLength - 1);

        for (let j = 0; j < circleSegments; j++) {
            const theta = (j / circleSegments) * Math.PI * 2;
            const localX = Math.cos(theta);
            const localY = Math.sin(theta);

            this.meshBuilder.appendVerticesInterleaved([
                0.0, 0.0, t,           // position: unused, unused, t
                0.0, 0.0, 1.0,         // normal: unused, unused, isTube=1
                localX, localY,        // texture0: unit circle coords
                gridX, gridY           // texture1: grid indices
            ]);
        }
    }

    // Generate indices for tube body
    for (let segment = 0; segment < pathLength - 1; segment++) {
        for (let i = 0; i < circleSegments; i++) {
            const current = startVertexIndex + segment * circleSegments + i;
            const next = startVertexIndex + segment * circleSegments + ((i + 1) % circleSegments);
            const currentNext = startVertexIndex + (segment + 1) * circleSegments + i;
            const nextNext = startVertexIndex + (segment + 1) * circleSegments + ((i + 1) % circleSegments);

            this.meshBuilder.appendIndices([
                current, next, currentNext,
                next, nextNext, currentNext
            ]);
        }
    }

    // Generate end caps for this tube
    this.generateSingleTubeCaps(gridX, gridY, startVertexIndex, pathLength, circleSegments);
}
```

The end caps are created by adding a center vertex and connecting it to the ring vertices in a fan pattern:

```typescript
private generateSingleTubeCaps(gridX: number, gridY: number, startVertexIndex: number, pathLength: number, circleSegments: number): void {
    const tubeVertexCount = pathLength * circleSegments;

    // START CAP (at t = 0)
    const startCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 0.0,         // position: unused, unused, t=0
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    for (let i = 0; i < circleSegments; i++) {
        const current = startVertexIndex + i;
        const next = startVertexIndex + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([startCapIndex, next, current]);
    }

    // END CAP (at t = 1)
    const endCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 1.0,         // position: unused, unused, t=1
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    const lastRingStart = startVertexIndex + (pathLength - 1) * circleSegments;
    for (let i = 0; i < circleSegments; i++) {
        const current = lastRingStart + i;
        const next = lastRingStart + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([endCapIndex, current, next]);
    }
}
```


Here's the complete worflow:
<WorkflowDiagramSimple
	client:load
	scriptLabel="TubeTest.ts"
	materialLabel="TestTubeShader.mat"
	materialCapture="tube-deformation-material.png"
	scriptCodeFile="TubeTest.ts"
	materialCodeFile="TubeTestShader.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/TestTubeDeformation.lspkg"
/>

<Chapter client:load id="chapter-2" number={2} title="Deforming the 3D Lines on the GPU" />

Deforming 3D lines has an added difficulty of preserving the volume of the tube.
If we just offset point positions by the same vector, we end up with wrong endcaps.

The solution is to compute a moving coordinate frame along the path. At each point, we calculate:
- a **Tangent (T)** vector: The direction the tube is heading (derivative of the path)
- a **Normal (N)** vector: Perpendicular to the tangent
- a **Binormal (B)** vector: Cross product of tangent and normal

Each vertex is then positioned using: `p = center + (cos θ · N + sin θ · B) · radius`
A key node from the material editor to make everything work is the Object to World converter.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeDeformation.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<div style={{ display: "flex", gap: "16px", justifyContent: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/test-tube-recording.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeTestDemo.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
</div>

<Chapter client:load id="chapter-3" number={3} title="Creating and Integrating a Vector Field" />
Now that we have a solid approach for procedural tube mesh deformation, we can deform the meshes along the vector field.
A vector field stores vector at each coordinate in space, so for each point of the tube's frame, we can sample that vector to infer the position change to apply.
If we keep the tubes' origin static, prevent their deformation along the frame but simply change their orientation, we get an actual arrow representation of the vector field.

To trace paths through the field, we integrate: starting from a sample point, we repeatedly query the field and step in that direction: `pos += field(pos) * stepSize`. At each step, we compute a local T/N/B (Tangent, Normal, Binormal) coordinate frame that follows the path curvature.

The shader supports several field presets, each with distinct flow characteristics:

<span id="contraction"></span>
#### 3.1 Contraction
Vectors spiral inward toward a target point, creating sink-like behavior.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldContraction.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.1a: Field visualization showing contraction flow pattern</p>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/contraction-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.1b: Demo on Spectacles</p>

<span id="expansion"></span>
#### 3.2 Expansion
Radial waves emanate outward from the target with 3D oscillation perpendicular to the flow.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldExpansion.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.2a: Field visualization showing expansion flow pattern</p>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/expansion-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.2b: Demo on Spectacles</p>

<span id="circulation"></span>
#### 3.3 Circulation
A 3D swirling vortex that mixes rotation in multiple planes around the target.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldCirculation.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.3a: Field visualization showing circulation flow pattern</p>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/circulation-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.3b: Demo on Spectacles</p>

<span id="vortex"></span>
#### 3.4 Vortex
Rotating cellular patterns with an added spin component based on angular position.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldVortex.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.4a: Field visualization showing vortex flow pattern</p>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/vortex-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.4b: Demo on Spectacles</p>

<span id="waves"></span>
#### 3.5 Waves
Sinusoidal interference patterns where each axis oscillates based on the other two coordinates.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/FieldWaves.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.5a: Field visualization showing wave interference pattern</p>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/waves-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 3.5b: Demo on Spectacles</p>

#### 3.6 Implementation Workflow

The complete workflow connects a TypeScript component that generates procedural tube geometry with a custom shader that integrates the vector field on the GPU:

<WorkflowDiagramSimple
	client:load
	scriptLabel="VectorField.ts"
	materialLabel="VectorField.mat"
	materialCapture="vector-field-material.png"
	scriptCodeFile="VectorField.ts"
	materialCodeFile="VectorField.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/VectorField.lspkg"
/>

<Chapter client:load id="chapter-4" number={4} title="Magnetic Field Visualization" />

Magnetic fields from dipole magnets follow a specific physical formula. Each dipole creates a field that depends on the magnetic moment and distance: `B = (3(m·r̂)r̂ - m) / r³`. When combining two dipoles, the resulting field creates the characteristic field line patterns seen around bar magnets.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/MagneticField.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 4.1: Magnetic field visualization showing dipole field computation and integration</p>

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/magnetic-field-demo.mp4"
	preload="metadata"
	maxWidth="100%"
/>
<p style={{ fontSize: "0.85em", color: "#888", textAlign: "center", fontStyle: "italic", marginTop: "4px" }}>Fig 4.2: Demo on Spectacles with interactive magnet positioning</p>

#### 4.1 Implementation Workflow

The magnetic field implementation uses the same tube mesh generation approach but with a physically-based dipole field formula in the shader:

<WorkflowDiagramSimple
	client:load
	scriptLabel="MagneticField.ts"
	materialLabel="MagneticField.mat"
	materialCapture="magnetic-field-material.png"
	scriptCodeFile="MagneticField.ts"
	materialCodeFile="MagneticField.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/MagneticField.lspkg"
/>

