---
title: "Vector Fields in Augmented Reality"
description: ""
pubDatetime: 2026-01-05T21:00:00Z
tags:
  [
    "augmented reality",
    "spectacles",
    "lens studio",
    "snap ar",
    "manim",
    "vector fields",

    "procedural geometry",
  ]
ogImage: /assets/MagneticFieldDemo.gif
draft: true
---
import WorkflowDiagram from "@components/WorkflowDiagram";
import WorkflowDiagramSimple from "@components/WorkflowDiagramSimple";
import ColorMixingChallenge from "@components/ColorMixingChallenge";
import CollapsibleVideo from "@components/CollapsibleVideo";
import HoverReveal from "@components/HoverReveal";
import CollapsibleCode from "@components/CollapsibleCode";
import ReferencePreview from "@components/ReferencePreview";
import Chapter from "@components/Chapter";
import ArticleTimeline from "@components/ArticleTimeline";
import VideoPlayer from "@components/VideoPlayer";
import SeriesNav from "@components/SeriesNav";
import VectorFieldViz from "@components/VectorFieldViz";

<div style={{ display: "flex", gap: "8px", justifyContent: "center", alignItems: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/Vector-Field-demo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/MagneticFieldDemo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
</div>

If you try to model the speed and direction of the wind that hits a plane, or the strengh and direction of the gravitational force that 
keeps satellites orbiting around the Earth, you will necessarily cross paths with Vector fields. 
If you want I'd recommend Bartosz Ciechanowsky Airfoil for a primer on the contexts where vector fields might be useful. https://ciechanow.ski/airfoil/

At their core, these are a mathematical structure that assign a value, in our case a vector for each point in space. If this vector only has one coordinates,
we call it scalar field. If it has less than three coordinates, we call it a vector field, and from 4 and above we call them Tensor Fields.
Each vector encodes the direction and magnitude. 

They're used to drive smoke simulations, fluid, advect particles, or influence soft body movement. 
Their visualization is generally done in one of either approaches: arrows, particles or trail lines. 

<VectorFieldViz client:load fieldType="dipole" />

<Chapter client:load id="chapter-1" number={1} title="Rendering 3D Lines" />

As of writing this, the best resource on Lens Studio's AssetStore
has an example made by Snap called VolumetricLine. This served as a great starting point. What are particles  but very stout lines? 
What are arrows but static lines with a pointer? If I could somehow render 2D lines, particles and 


<CollapsibleCode
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/scripts/VolumetricLine.ts"
	trigger="View VolumetricLine.ts"
	language="typescript"
/>

The tube body is generated by creating rings of vertices along the length, then connecting them with triangles:

```typescript
private generateSingleTube(gridX: number, gridY: number, pathLength: number, circleSegments: number): void {
    const startVertexIndex = this.meshBuilder.getVerticesCount();

    // Generate tube body vertices
    for (let i = 0; i < pathLength; i++) {
        const t = i / (pathLength - 1);

        for (let j = 0; j < circleSegments; j++) {
            const theta = (j / circleSegments) * Math.PI * 2;
            const localX = Math.cos(theta);
            const localY = Math.sin(theta);

            this.meshBuilder.appendVerticesInterleaved([
                0.0, 0.0, t,           // position: unused, unused, t
                0.0, 0.0, 1.0,         // normal: unused, unused, isTube=1
                localX, localY,        // texture0: unit circle coords
                gridX, gridY           // texture1: grid indices
            ]);
        }
    }

    // Generate indices for tube body
    for (let segment = 0; segment < pathLength - 1; segment++) {
        for (let i = 0; i < circleSegments; i++) {
            const current = startVertexIndex + segment * circleSegments + i;
            const next = startVertexIndex + segment * circleSegments + ((i + 1) % circleSegments);
            const currentNext = startVertexIndex + (segment + 1) * circleSegments + i;
            const nextNext = startVertexIndex + (segment + 1) * circleSegments + ((i + 1) % circleSegments);

            this.meshBuilder.appendIndices([
                current, next, currentNext,
                next, nextNext, currentNext
            ]);
        }
    }

    // Generate end caps for this tube
    this.generateSingleTubeCaps(gridX, gridY, startVertexIndex, pathLength, circleSegments);
}
```

The end caps are created by adding a center vertex and connecting it to the ring vertices in a fan pattern:

```typescript
private generateSingleTubeCaps(gridX: number, gridY: number, startVertexIndex: number, pathLength: number, circleSegments: number): void {
    const tubeVertexCount = pathLength * circleSegments;

    // START CAP (at t = 0)
    const startCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 0.0,         // position: unused, unused, t=0
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    for (let i = 0; i < circleSegments; i++) {
        const current = startVertexIndex + i;
        const next = startVertexIndex + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([startCapIndex, next, current]);
    }

    // END CAP (at t = 1)
    const endCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 1.0,         // position: unused, unused, t=1
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    const lastRingStart = startVertexIndex + (pathLength - 1) * circleSegments;
    for (let i = 0; i < circleSegments; i++) {
        const current = lastRingStart + i;
        const next = lastRingStart + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([endCapIndex, current, next]);
    }
}
```

The construction process can be summarized as following:
<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeConstruction.webm"
	preload="metadata"
	maxWidth="100%"
	noBorder={true}
/>

Here's the complete worflow:
<WorkflowDiagramSimple
	client:load
	scriptLabel="TubeTest.ts"
	materialLabel="TestTubeShader.mat"
	materialCapture="tube-deformation-material.png"
	scriptCodeFile="TubeTest.ts"
	materialCodeFile="TubeTestShader.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
	packagePath="Vector-Fields/exports/TestTubeDeformation.lspkg"
/>

<Chapter client:load id="chapter-3" number={3} title="Deforming the 3D Lines on the GPU" />

Deforming 3D lines has an added difficulty of preserving the volume of the tube. 
If we just offset point positions by the same vector, we end up with an wrong endcaps.
<div style={{ display: "flex", gap: "16px", justifyContent: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/test-tube-recording.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeTestDemo.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
</div>

<Chapter client:load id="chapter-3" number={3} title="Creating and integrating a Vector Field" />
Here's what this looks like when rendered on AR glasses:


