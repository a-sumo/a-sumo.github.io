---
title: "Vector Fields in Augmented Reality"
description: ""
pubDatetime: 2026-01-05T21:00:00Z
tags:
  [
    "augmented reality",
    "spectacles",
    "lens studio",
    "snap ar",
    "manim",
    "vector fields",

    "procedural geometry",
  ]
ogImage: /assets/Vector-Field-demo.gif
draft: true
---
import WorkflowDiagram from "@components/WorkflowDiagram";
import WorkflowDiagramSimple from "@components/WorkflowDiagramSimple";
import ColorMixingChallenge from "@components/ColorMixingChallenge";
import CollapsibleVideo from "@components/CollapsibleVideo";
import HoverReveal from "@components/HoverReveal";
import CollapsibleCode from "@components/CollapsibleCode";
import ReferencePreview from "@components/ReferencePreview";
import Chapter from "@components/Chapter";
import ArticleTimeline from "@components/ArticleTimeline";
import VideoPlayer from "@components/VideoPlayer";
import SeriesNav from "@components/SeriesNav";

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/Vector-Field-demo.mp4"
	autoPlay={true}
	preload="auto"
/>

<Chapter client:load id="chapter-1" number={1} title="Rendering 3D Lines" />

As of writing this, the best resource on Lens Studio's AssetStore
has an example made by Snap called VolumetricLine. This served as a great starting point.

<CollapsibleCode
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/scripts/VolumetricLine.ts"
	trigger="View VolumetricLine.ts"
	language="typescript"
/>

We use the MeshBuilder API to create tubes, then deform them on the GPU.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeConstruction.mp4"
	preload="metadata"
	maxWidth="100%"
/>

The tube body is generated by creating rings of vertices along the length, then connecting them with triangles:

<CollapsibleCode
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/tube_construction.py"
	trigger="View manim source"
	language="python"
/>

```typescript
private generateSingleTube(gridX: number, gridY: number, pathLength: number, circleSegments: number): void {
    const startVertexIndex = this.meshBuilder.getVerticesCount();

    // Generate tube body vertices
    for (let i = 0; i < pathLength; i++) {
        const t = i / (pathLength - 1);

        for (let j = 0; j < circleSegments; j++) {
            const theta = (j / circleSegments) * Math.PI * 2;
            const localX = Math.cos(theta);
            const localY = Math.sin(theta);

            this.meshBuilder.appendVerticesInterleaved([
                0.0, 0.0, t,           // position: unused, unused, t
                0.0, 0.0, 1.0,         // normal: unused, unused, isTube=1
                localX, localY,        // texture0: unit circle coords
                gridX, gridY           // texture1: grid indices
            ]);
        }
    }

    // Generate indices for tube body
    for (let segment = 0; segment < pathLength - 1; segment++) {
        for (let i = 0; i < circleSegments; i++) {
            const current = startVertexIndex + segment * circleSegments + i;
            const next = startVertexIndex + segment * circleSegments + ((i + 1) % circleSegments);
            const currentNext = startVertexIndex + (segment + 1) * circleSegments + i;
            const nextNext = startVertexIndex + (segment + 1) * circleSegments + ((i + 1) % circleSegments);

            this.meshBuilder.appendIndices([
                current, next, currentNext,
                next, nextNext, currentNext
            ]);
        }
    }

    // Generate end caps for this tube
    this.generateSingleTubeCaps(gridX, gridY, startVertexIndex, pathLength, circleSegments);
}
```

The end caps are created by adding a center vertex and connecting it to the ring vertices in a fan pattern:

```typescript
private generateSingleTubeCaps(gridX: number, gridY: number, startVertexIndex: number, pathLength: number, circleSegments: number): void {
    const tubeVertexCount = pathLength * circleSegments;

    // START CAP (at t = 0)
    const startCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 0.0,         // position: unused, unused, t=0
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    for (let i = 0; i < circleSegments; i++) {
        const current = startVertexIndex + i;
        const next = startVertexIndex + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([startCapIndex, next, current]);
    }

    // END CAP (at t = 1)
    const endCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 1.0,         // position: unused, unused, t=1
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    const lastRingStart = startVertexIndex + (pathLength - 1) * circleSegments;
    for (let i = 0; i < circleSegments; i++) {
        const current = lastRingStart + i;
        const next = lastRingStart + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([endCapIndex, current, next]);
    }
}
```
Here's the complete worflow:
<WorkflowDiagramSimple
	client:load
	scriptLabel="TubeTest.ts"
	materialLabel="TubeTestShader.js"
	materialCapture="tube_material.png"
	scriptCodeFile="TubeTest.ts"
	materialCodeFile="TubeTestShader.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
/>


<Chapter client:load id="chapter-3" number={3} title="Deforming the Lines on the GPU" />

<div style={{ display: "flex", gap: "16px", justifyContent: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/test-tube-recording.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeTestDemo.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
</div>

<Chapter client:load id="chapter-3" number={3} title="Creating a Vector Field" />
<Chapter client:load id="chapter-4" number={4} title="Integrating a Vector Field" />

<Chapter client:load id="chapter-5" number={5} title="UX Considerations" />