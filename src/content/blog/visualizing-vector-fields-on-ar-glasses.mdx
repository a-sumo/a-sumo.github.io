---
title: "Vector Fields in Augmented Reality"
description: ""
pubDatetime: 2026-01-05T21:00:00Z
tags:
  [
    "augmented reality",
    "spectacles",
    "lens studio",
    "snap ar",
    "manim",
    "vector fields",

    "procedural geometry",
  ]
ogImage: /assets/MagneticFieldDemo.gif
draft: true
---
import WorkflowDiagram from "@components/WorkflowDiagram";
import WorkflowDiagramSimple from "@components/WorkflowDiagramSimple";
import ColorMixingChallenge from "@components/ColorMixingChallenge";
import CollapsibleVideo from "@components/CollapsibleVideo";
import HoverReveal from "@components/HoverReveal";
import CollapsibleCode from "@components/CollapsibleCode";
import ReferencePreview from "@components/ReferencePreview";
import Chapter from "@components/Chapter";
import ArticleTimeline from "@components/ArticleTimeline";
import VideoPlayer from "@components/VideoPlayer";
import SeriesNav from "@components/SeriesNav";
import VectorFieldViz from "@components/VectorFieldViz";

If you try to model the speed and direction of the wind that hits a plane, or the strengh and direction of the gravitational force that 
keeps satellites orbiting around the Earth, you will necessarily cross paths with Vector fields. 
If you want I'd recommend Bartosz Ciechanowsky Airfoil for a primer on the contexts where vector fields might be useful. https://ciechanow.ski/airfoil/

At their core, these are a mathematical structure that assign a value, in our case a vector for each point in space. If this vector only has one coordinates,
we call it scalar field. If it has less than three coordinates, we call it a vector field, and from 4 and above we call them Tensor Fields.
Each vector encodes the direction and magnitude. 

They're used to drive smoke simulations, fluid, advect particles, or influence soft body movement. 
But visualizing them has always been a challenge. Arrows, Particles or Trail Lines. 


<VectorFieldViz client:load fieldType="dipole" />

Here's what this looks like when rendered on AR glasses:

<div style={{ display: "flex", gap: "8px", justifyContent: "center", alignItems: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/Vector-Field-demo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/MagneticFieldDemo.mp4"
		autoPlay={true}
		preload="auto"
		maxWidth="100%"
	/>
</div>

<Chapter client:load id="chapter-1" number={1} title="Rendering 3D Lines" />

As of writing this, the best resource on Lens Studio's AssetStore
has an example made by Snap called VolumetricLine. This served as a great starting point. What are particles  but very stout lines? 
What are arrows but static lines with a pointer? If I could somehow render 2D lines, particles and 


<CollapsibleCode
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/scripts/VolumetricLine.ts"
	trigger="View VolumetricLine.ts"
	language="typescript"
/>

We use the MeshBuilder API to create tubes, then deform them on the GPU.

<VideoPlayer
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeConstruction.mp4"
	preload="metadata"
	maxWidth="100%"
/>

The tube body is generated by creating rings of vertices along the length, then connecting them with triangles:

<CollapsibleCode
	client:load
	src="/assets/visualizing-vector-fields-on-ar-glasses/tube_construction.py"
	trigger="View manim source"
	language="python"
/>

```typescript
private generateSingleTube(gridX: number, gridY: number, pathLength: number, circleSegments: number): void {
    const startVertexIndex = this.meshBuilder.getVerticesCount();

    // Generate tube body vertices
    for (let i = 0; i < pathLength; i++) {
        const t = i / (pathLength - 1);

        for (let j = 0; j < circleSegments; j++) {
            const theta = (j / circleSegments) * Math.PI * 2;
            const localX = Math.cos(theta);
            const localY = Math.sin(theta);

            this.meshBuilder.appendVerticesInterleaved([
                0.0, 0.0, t,           // position: unused, unused, t
                0.0, 0.0, 1.0,         // normal: unused, unused, isTube=1
                localX, localY,        // texture0: unit circle coords
                gridX, gridY           // texture1: grid indices
            ]);
        }
    }

    // Generate indices for tube body
    for (let segment = 0; segment < pathLength - 1; segment++) {
        for (let i = 0; i < circleSegments; i++) {
            const current = startVertexIndex + segment * circleSegments + i;
            const next = startVertexIndex + segment * circleSegments + ((i + 1) % circleSegments);
            const currentNext = startVertexIndex + (segment + 1) * circleSegments + i;
            const nextNext = startVertexIndex + (segment + 1) * circleSegments + ((i + 1) % circleSegments);

            this.meshBuilder.appendIndices([
                current, next, currentNext,
                next, nextNext, currentNext
            ]);
        }
    }

    // Generate end caps for this tube
    this.generateSingleTubeCaps(gridX, gridY, startVertexIndex, pathLength, circleSegments);
}
```

The end caps are created by adding a center vertex and connecting it to the ring vertices in a fan pattern:

```typescript
private generateSingleTubeCaps(gridX: number, gridY: number, startVertexIndex: number, pathLength: number, circleSegments: number): void {
    const tubeVertexCount = pathLength * circleSegments;

    // START CAP (at t = 0)
    const startCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 0.0,         // position: unused, unused, t=0
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    for (let i = 0; i < circleSegments; i++) {
        const current = startVertexIndex + i;
        const next = startVertexIndex + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([startCapIndex, next, current]);
    }

    // END CAP (at t = 1)
    const endCapIndex = this.meshBuilder.getVerticesCount();
    this.meshBuilder.appendVerticesInterleaved([
        0.0, 0.0, 1.0,         // position: unused, unused, t=1
        0.0, 0.0, 0.0,         // normal: unused, unused, isCap=0
        0.0, 0.0,              // texture0: center
        gridX, gridY           // texture1: grid indices
    ]);

    const lastRingStart = startVertexIndex + (pathLength - 1) * circleSegments;
    for (let i = 0; i < circleSegments; i++) {
        const current = lastRingStart + i;
        const next = lastRingStart + (i + 1) % circleSegments;
        this.meshBuilder.appendIndices([endCapIndex, current, next]);
    }
}
```
Here's the complete worflow:
<WorkflowDiagramSimple
	client:load
	scriptLabel="TubeTest.ts"
	materialLabel="TubeTestShader.js"
	materialCapture="tube_material.png"
	scriptCodeFile="TubeTest.ts"
	materialCodeFile="TubeTestShader.js"
	basePath="/assets/visualizing-vector-fields-on-ar-glasses"
/>


<Chapter client:load id="chapter-3" number={3} title="Deforming the Lines on the GPU" />

<div style={{ display: "flex", gap: "16px", justifyContent: "center" }}>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/test-tube-recording.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
	<VideoPlayer
		client:load
		src="/assets/visualizing-vector-fields-on-ar-glasses/videos/TubeTestDemo.mp4"
		preload="metadata"
		maxWidth="100%"
	/>
</div>

<Chapter client:load id="chapter-3" number={3} title="Creating a Vector Field" />
<Chapter client:load id="chapter-4" number={4} title="Integrating a Vector Field" />

<Chapter client:load id="chapter-5" number={5} title="UX Considerations" />